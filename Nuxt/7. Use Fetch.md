1、$fetch, useAsyncData

[useAsyncData文档](https://nuxt.com/docs/4.x/api/composables/use-async-data)

[$fetch文档](https://nuxt.com/docs/api/utils/dollarfetch)

```
// 参数：
  // key：一个唯一键，用于确保数据提取能够在请求之间正确去重。如果您不提供键，那么useAsyncData将为您生成一个与实例的文件名和行号唯一的键。
  // handler：必须返回真值的异步函数（例如，它不应该是undefined或null），否则请求可能会在客户端重复
  // options：
  //   server：是否在服务器上获取数据（默认为true）
  //   lazy：是否在加载路由后解析异步函数，而不是阻止客户端导航（默认为false）
  //   immediate：设置为 时false，将阻止请求立即触发。（默认为true）
  //   defaultdata：一个工厂函数，用于在异步函数解析之前设置 的默认值- 与lazy: true或immediate: false选项一起使用
  //   transformhandler：解析后可用于改变函数结果的函数
  //   getCachedData：提供返回缓存数据的函数。返回值为空或未定义将触发提取。默认情况下，这是：key => nuxt.isHydrating ? nuxt.payload.data[key] : nuxt.static.data[key]，仅当payloadExtraction启用时才会缓存数据。
  //   pick：仅从handler函数结果中选取此数组中的指定键
  //   watch：观察反应源是否自动刷新
  //   deep：以深层引用对象的形式返回数据（true默认情况下如此）。可以将其设置false为以浅层引用对象的形式返回数据，如果您的数据不需要深度响应，这可以提高性能。
  //   dedupe：避免一次多次获取相同的键（默认为cancel）。可能的选项：
  //     cancel- 当有新请求时取消现有请求
  //     defer- 如果有待处理的请求，则根本不会发出新请求
  ```
  
  ```
const result = await useAsyncData('get', () => $fetch('/api/hello'))
```

```

```


2、useFetch

```
// 参数：
  // URL：要获取的 URL。
  // Options（扩展unjs/ofetch选项和AsyncDataOptions）：
  //   key：一个唯一键，用于确保数据提取能够在请求之间正确地进行重复数据删除，如果未提供，它将根据 URL 和提取选项自动生成
  //   server：是否在服务器上获取数据（默认为true）
  //   lazy：是否在加载路由后解析异步函数，而不是阻止客户端导航（默认为false）
  //   immediate：设置为 时false，将阻止请求立即触发。（默认为true）
  //   defaultdata：一个工厂函数，用于在异步函数解析之前设置 的默认值- 与lazy: true或immediate: false选项一起使用
  //   transformhandler：解析后可用于改变函数结果的函数
  //   getCachedData：提供返回缓存数据的函数。返回值为空或未定义将触发提取。默认情况下，这是：key => nuxt.isHydrating ? nuxt.payload.data[key] : nuxt.static.data[key]，仅当payloadExtraction启用时才会缓存数据。
  //   pick：仅从handler函数结果中选取此数组中的指定键
  //   watch：监视一系列响应式源，并在它们发生变化时自动刷新获取结果。默认情况下，会监视获取选项和 URL。您可以使用 完全忽略响应式源watch: false。与 结合使用immediate: false，这可以实现完全手动的useFetch。（您可以在此处看到使用 的示例watch。）
  //   deep：以深层引用对象的形式返回数据（true默认情况下如此）。可以将其设置false为以浅层引用对象的形式返回数据，如果您的数据不需要深度响应，这可以提高性能。
  //   dedupe：避免一次多次获取相同的键（默认为cancel）。可能的选项：
  //     cancel- 当有新请求时取消现有请求
  //     defer- 如果有待处理的请求，则根本不会发出新请求
  ```
  
  
  ```
  const { data, status, error, refresh, clear } = await useFetch('/api/user')
  ```
  
  ```
  // 返回值：
  // data：传入的异步函数的结果。
  // refresh/ execute：一个函数，可以用来刷新该handler函数返回的数据。
  // error：如果数据获取失败则返回错误对象。
  // status：表示数据请求状态的字符串（"idle"，"pending"，"success"，"error"）。
  // clear：一个函数，它将设置data为undefined，设置error为null，设置status为'idle'，并将任何当前待处理的请求标记为已取消。
  ```
  